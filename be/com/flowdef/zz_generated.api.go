// +build !generator

// Code generated by generator api. DO NOT EDIT.

package flowdef

import (
	context "context"
	fmt "fmt"
	http "net/http"

	flowdeftypes "github.com/olvrng/rbot/be/com/flowdef/types"
	httprpc "github.com/olvrng/rbot/be/pkg/httprpc"
)

func init() {
	httprpc.Register(NewServer)
}

func NewServer(builder interface{}, hooks ...httprpc.HooksBuilder) (httprpc.Server, bool) {
	switch builder := builder.(type) {
	case func() EditorService:
		return NewEditorServiceServer(builder, hooks...), true
	case EditorService:
		fn := func() EditorService { return builder }
		return NewEditorServiceServer(fn, hooks...), true
	case func() QueryService:
		return NewQueryServiceServer(builder, hooks...), true
	case QueryService:
		fn := func() QueryService { return builder }
		return NewQueryServiceServer(fn, hooks...), true
	default:
		return nil, false
	}
}

type EditorServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() EditorService
}

func NewEditorServiceServer(builder func() EditorService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &EditorServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const EditorServicePathPrefix = "/api/flow/def/editor/"

const Path_Editor_CreateFlow = "/api/flow/def/editor/CreateFlow"
const Path_Editor_UpdateFlow = "/api/flow/def/editor/UpdateFlow"

func (s *EditorServiceServer) PathPrefix() string {
	return EditorServicePathPrefix
}

func (s *EditorServiceServer) WithHooks(hooks httprpc.HooksBuilder) httprpc.Server {
	result := *s
	result.hooks = httprpc.ChainHooks(s.hooks, hooks)
	return &result
}

func (s *EditorServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks)
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.RequestReceived(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *EditorServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg httprpc.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/api/flow/def/editor/CreateFlow":
		msg := &flowdeftypes.CreateFlowRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp httprpc.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.CreateFlow(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/api/flow/def/editor/UpdateFlow":
		msg := &flowdeftypes.CreateFlowRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp httprpc.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.UpdateFlow(newCtx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}

type QueryServiceServer struct {
	hooks   httprpc.HooksBuilder
	builder func() QueryService
}

func NewQueryServiceServer(builder func() QueryService, hooks ...httprpc.HooksBuilder) httprpc.Server {
	return &QueryServiceServer{
		hooks:   httprpc.ChainHooks(hooks...),
		builder: builder,
	}
}

const QueryServicePathPrefix = "/api/flow/def/query/"

const Path_Query_GetFlowByID = "/api/flow/def/query/GetFlowByID"
const Path_Query_GetFlowByParam = "/api/flow/def/query/GetFlowByParam"

func (s *QueryServiceServer) PathPrefix() string {
	return QueryServicePathPrefix
}

func (s *QueryServiceServer) WithHooks(hooks httprpc.HooksBuilder) httprpc.Server {
	result := *s
	result.hooks = httprpc.ChainHooks(s.hooks, hooks)
	return &result
}

func (s *QueryServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	hooks := httprpc.WrapHooks(s.hooks)
	ctx, info := req.Context(), &httprpc.HookInfo{Route: req.URL.Path, HTTPRequest: req}
	ctx, err := hooks.RequestReceived(ctx, *info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve, err := httprpc.ParseRequestHeader(req)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	reqMsg, exec, err := s.parseRoute(req.URL.Path, hooks, info)
	if err != nil {
		httprpc.WriteError(ctx, resp, hooks, *info, err)
		return
	}
	serve(ctx, resp, req, hooks, info, reqMsg, exec)
}

func (s *QueryServiceServer) parseRoute(path string, hooks httprpc.Hooks, info *httprpc.HookInfo) (reqMsg httprpc.Message, _ httprpc.ExecFunc, _ error) {
	switch path {
	case "/api/flow/def/query/GetFlowByID":
		msg := &flowdeftypes.GetFlowByIDRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp httprpc.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetFlowByID(newCtx, msg)
			return
		}
		return msg, fn, nil
	case "/api/flow/def/query/GetFlowByParam":
		msg := &flowdeftypes.GetFlowByParamRequest{}
		fn := func(ctx context.Context) (newCtx context.Context, resp httprpc.Message, err error) {
			inner := s.builder()
			info.Request, info.Inner = msg, inner
			newCtx, err = hooks.RequestRouted(ctx, *info)
			if err != nil {
				return
			}
			resp, err = inner.GetFlowByParam(newCtx, msg)
			return
		}
		return msg, fn, nil
	default:
		msg := fmt.Sprintf("no handler for path %q", path)
		return nil, nil, httprpc.BadRouteError(msg, "POST", path)
	}
}
